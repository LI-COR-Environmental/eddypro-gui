/***************************************************************************
  planarfitsettingsdialog.cpp
  -------------------
  Copyright (C) 2011-2015, LI-COR Biosciences
  Author: Antonio Forgione

  This file is part of EddyPro (R).

  EddyPro (R) is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  EddyPro (R) is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with EddyPro (R). If not, see <http://www.gnu.org/licenses/>.
****************************************************************************/

#include "planarfitsettingsdialog.h"

#include <QButtonGroup>
#include <QDoubleSpinBox>
#include <QFileDialog>
#include <QGridLayout>
#include <QCheckBox>
#include <QComboBox>
#include <QDateEdit>
#include <QDebug>
#include <QEvent>
#include <QHeaderView>
#include <QPushButton>
#include <QRadioButton>
#include <QScrollArea>
#include <QSpinBox>
#include <QTimeEdit>
#include <QToolButton>

#include "ancillaryfiletest.h"
#include "angle_tablemodel.h"
#include "angle_tableview.h"
#include "angles_view.h"
#include "clicklabel.h"
#include "configstate.h"
#include "customclearlineedit.h"
#include "dbghelper.h"
#include "ecproject.h"
#include "filebrowsewidget.h"
#include "fileutils.h"
#include "globalsettings.h"
#include "widget_utils.h"

PlanarFitSettingsDialog::PlanarFitSettingsDialog(QWidget* parent, EcProject *ecProject, ConfigState* config) :
    QDialog(parent),
    ecProject_(ecProject),
    configState_(config)
{
    setWindowModality(Qt::WindowModal);
    setWindowTitle(tr("Planar Fit Settings"));
    WidgetUtils::removeContextHelpButton(this);

    auto groupTitle = new QLabel;
    groupTitle->setText(tr("If you already ran EddyPro with the Planar Fit option for this dataset, <br />"
                           "you probably have a file named \"eddypro_<i>projID</i>_planarfit.txt\" in the results folder. <br />"
                           "You may use that file and speed up the data processing."));

    auto hrLabel_1 = new QLabel;
    hrLabel_1->setObjectName(QStringLiteral("hrLabel"));

    hrLabel_2 = new QLabel;
    hrLabel_2->setObjectName(QStringLiteral("hrLabel"));

    existingRadio = new QRadioButton(tr("Planar fit file available : "));
    existingRadio->setToolTip(tr("<b>Planar fit file available:</b> If you got a satisfying planar fit assessment in a previous run with EddyPro, which applies to the current dataset, you can use the same assessment by providing the path to the file \"eddypro_planar_fit_ID.txt\" generated by EddyPro in the previous run, containing the results of the assessment. This will shorten program execution time, and assure full comparability between current and previous results."));

    nonExistingRadio = new QRadioButton(tr("Planar fit file not available :"));
    nonExistingRadio->setToolTip(tr("<b>Planar fit file not available:</b> Choose this option and provide the following information if you need to calculate (sector-wise) planar fit rotation matrices for your dataset. Planar fit assessment will be completed first, and then the raw data processing and flux computation procedures will automatically be performed."));

    subsetCheckBox = new QCheckBox;
    subsetCheckBox->setText(tr("Select a different period"));
    subsetCheckBox->setStyleSheet(QStringLiteral("QCheckBox {margin: 0px;}"));
    subsetCheckBox->setToolTip(tr("<b>Select a different period:</b> Select this option and set the corresponding dates to specify the time period EddyPro will use for the planar fit calculations. This subperiod must fall within the time period defined by the available raw data, but does not necessarily need to fall within the subperiod that you may have possibly selected in the Basic Settings page."));

    startDateLabel = new ClickLabel(this);
    startDateLabel->setText(tr("Start :"));
    startDateLabel->setToolTip(tr("<b>Start:</b> Starting date of the time period to be used for planar fit assessment. This time period cannot be longer than about 1 month. As a general recommendation, select a time period during which the instrument setup and the canopy height and structure did not undergo major modifications. Results obtained using a given time period (e.g., 2 weeks) can be used for processing a longer time period, in which major modifications did not occur at the site. The higher the <b><i>Number of wind sectors</i></b> and the <b><i>Minimum number of elements per sector</i></b>, the longer the period should be."));
    startDateEdit = new QDateEdit;
    startDateEdit->setToolTip(startDateLabel->toolTip());
    startDateEdit->setCalendarPopup(true);
    WidgetUtils::customizeCalendar(startDateEdit->calendarWidget());

    startTimeEdit = new QTimeEdit;
    startTimeEdit->setDisplayFormat(QStringLiteral("hh:mm"));
    startTimeEdit->setAccelerated(true);

    lockedIcon = new QLabel;
    auto pixmap = QPixmap(QStringLiteral(":/icons/vlink-locked"));
#if defined(Q_OS_MAC)
    pixmap.setDevicePixelRatio(2.0);
#endif
    lockedIcon->setPixmap(pixmap);

    endDateLabel = new ClickLabel(this);
    endDateLabel->setText(tr("End :"));
    endDateLabel->setToolTip(tr("<b>End:</b> End date of the time period to be used for planar fit assessment. This time period cannot be longer than about 1 month. As a general recommendation, select a time period during which the instrument setup and the canopy height and structure did not undergo major modifications. Results obtained using a given time period (e.g., 2 weeks) can be used for processing a longer time period, in which major modifications did not occur at the site. The higher the <b><i>Number of wind sectors</i></b> and the <b><i>Minimum number of elements per sector</i></b>, the longer the period should be."));
    endDateEdit = new QDateEdit;
    endDateEdit->setToolTip(endDateLabel->toolTip());
    endDateEdit->setCalendarPopup(true);
    WidgetUtils::customizeCalendar(endDateEdit->calendarWidget());

    endTimeEdit = new QTimeEdit;
    endTimeEdit->setDisplayFormat(QStringLiteral("hh:mm"));
    endTimeEdit->setAccelerated(true);

    auto dateTimeContainer = new QGridLayout;
    dateTimeContainer->addWidget(startDateEdit, 0, 1);
    dateTimeContainer->addWidget(startTimeEdit, 0, 2);
    dateTimeContainer->addWidget(lockedIcon, 0, 0, 2, 1);
    dateTimeContainer->addWidget(endDateEdit, 1, 1);
    dateTimeContainer->addWidget(endTimeEdit, 1, 2);
    dateTimeContainer->setColumnStretch(1, 1);
    dateTimeContainer->setColumnStretch(2, 1);
    dateTimeContainer->setColumnStretch(3, 2);
    dateTimeContainer->setContentsMargins(0, 0, 0, 0);
    dateTimeContainer->setVerticalSpacing(3);

    fileBrowse = new FileBrowseWidget;
    fileBrowse->setToolTip(tr("<b>Load:</b> Load an existing planar fit file"));
    fileBrowse->setDialogTitle(tr("Select the Planar Fit File"));
    fileBrowse->setDialogWorkingDir(WidgetUtils::getSearchPathHint());
    fileBrowse->setDialogFilter(tr("All Files (*.*)"));

    auto existingFileLayout = new QHBoxLayout;
    existingFileLayout->addWidget(existingRadio);
    existingFileLayout->addWidget(fileBrowse);
    existingFileLayout->setStretch(2, 1);
    existingFileLayout->setContentsMargins(0, 0, 0, 0);
    existingFileLayout->setSpacing(0);

    radioGroup = new QButtonGroup(this);
    radioGroup->addButton(existingRadio, 0);
    radioGroup->addButton(nonExistingRadio, 1);

    itemPerSectorLabel = new ClickLabel(tr("Minimum number of elements per sector :"));
    itemPerSectorLabel->setToolTip(tr("<b>Minimum number of elements per sector:</b> Enter the minimum number of mean wind vectors (calculated over each flux averaging interval), required to calculate planar fit rotation matrices. A too small number may lead to inaccurate regressions and rotation matrices. A too large number may lead to sectors without planar fit rotation matrices. If for a certain averaging interval, wind is blowing from a sector for which the rotation matrix could not be calculated, the policy selected in <b><i>If planar fit calculations fail for a sector</i></b> apply."));
    itemPerSectorSpin = new QSpinBox;
    itemPerSectorSpin->setRange(0, 10000);
    itemPerSectorSpin->setSpecialValueText(tr("Not set"));
    itemPerSectorSpin->setAccelerated(true);
    itemPerSectorSpin->setToolTip(itemPerSectorLabel->toolTip());

    maxAvgWLabel = new ClickLabel(tr("Maximum mean vertical wind component :"));
    maxAvgWLabel->setToolTip(tr("<b>Maximum mean vertical wind component:</b> Set a maximum vertical wind component to instruct EddyPro to ignore flux averaging periods with larger mean vertical wind components, when calculating the rotation matrices. Using elements with too large (unrealistic) vertical wind components would corrupt the assessment of the fitting plane, and of the related rotation matrices."));
    maxAvgWSpin = new QDoubleSpinBox;
    maxAvgWSpin->setDecimals(3);
    maxAvgWSpin->setRange(0.099, 10.000);
    maxAvgWSpin->setSpecialValueText(tr("Not set"));
    maxAvgWSpin->setSingleStep(0.001);
    maxAvgWSpin->setAccelerated(true);
    maxAvgWSpin->setSuffix(tr("  [m/s]", "Velocity"));
    maxAvgWSpin->setToolTip(maxAvgWLabel->toolTip());

    minAvgULabel = new ClickLabel(tr("Minimum mean horizontal wind component :"));
    minAvgULabel->setToolTip(tr("<b>Minimum mean horizontal wind component:</b> Set a minimum horizontal wind component to instruct EddyPro to ignore flux averaging periods with smaller mean horizontal wind components, when calculating the rotation matrices. When the horizontal wind is very small, the attack angle may be affected by large errors, and so would be the vertical wind component, resulting in poor quality data that would degrade the planar fit assessment."));
    minAvgUSpin = new QDoubleSpinBox;
    minAvgUSpin->setDecimals(3);
    minAvgUSpin->setRange(-0.001, 10.000);
    minAvgUSpin->setSpecialValueText(tr("Not set"));
    minAvgUSpin->setSingleStep(0.001);
    minAvgUSpin->setAccelerated(true);
    minAvgUSpin->setSuffix(tr("  [m/s]", "Velocity"));
    minAvgUSpin->setToolTip(minAvgULabel->toolTip());

    fixPolicyLabel = new ClickLabel(tr("If planar fit calculations fail for a sector :"));
    fixPolicyLabel->setToolTip(tr("<b>If planar fit calculations fail for a sector:</b> Select how EddyPro should behave when encountering data from a wind sector, for which the planar fit rotation matrix could not be calculated for any reason. Either use the rotation matrix for the closest sector (clockwise or counterclockwise), or switch to double-rotations for that sector."));
    fixPolicyCombo = new QComboBox;
    fixPolicyCombo->addItem(tr("Use closest valid sector, clockwise"));
    fixPolicyCombo->addItem(tr("Use closest valid sector, counterclockwise"));
    fixPolicyCombo->addItem(tr("Use double rotations"));
    fixPolicyCombo->setToolTip(fixPolicyLabel->toolTip());

    auto propertiesLayout = new QGridLayout;
    propertiesLayout->addLayout(existingFileLayout, 0, 0, 1, -1);
    propertiesLayout->addWidget(nonExistingRadio, 1, 0);
    propertiesLayout->addWidget(subsetCheckBox, 1, 1, 1, 1, Qt::AlignLeft);
    propertiesLayout->addWidget(startDateLabel, 1, 1, Qt::AlignRight);
    propertiesLayout->addLayout(dateTimeContainer, 1, 2, 2, 1);
    propertiesLayout->addWidget(endDateLabel, 2, 1, Qt::AlignRight);
    propertiesLayout->addWidget(itemPerSectorLabel, 3, 1, Qt::AlignRight);
    propertiesLayout->addWidget(itemPerSectorSpin, 3, 2, 1, 1);
    propertiesLayout->addWidget(maxAvgWLabel, 4, 1, Qt::AlignRight);
    propertiesLayout->addWidget(maxAvgWSpin, 4, 2, 1, 1);
    propertiesLayout->addWidget(minAvgULabel, 5, 1, Qt::AlignRight);
    propertiesLayout->addWidget(minAvgUSpin, 5, 2, 1, 1);
    propertiesLayout->addWidget(fixPolicyLabel, 6, 0, Qt::AlignRight);
    propertiesLayout->addWidget(fixPolicyCombo, 6, 1);
    propertiesLayout->setRowStretch(7, 1);
    propertiesLayout->setVerticalSpacing(3);
    propertiesLayout->setRowMinimumHeight(2, 10);
    propertiesLayout->setContentsMargins(3, 3, 3, 3);

    auto propertiesFrame = new QWidget;
    propertiesFrame->setLayout(propertiesLayout);
    propertiesFrame->setProperty("scrollContainerWidget", true);
    propertiesFrame->setMinimumWidth(propertiesFrame->sizeHint().width());

    sectorConfigTitle = new QLabel(tr("Configure wind sectors"));
    sectorConfigTitle->setProperty("groupLabel", true);

    setupModel();
    setupViews();

    auto buttonsLayout = new QVBoxLayout;
    buttonsLayout->addWidget(addButton);
    buttonsLayout->addSpacing(10);
    buttonsLayout->addWidget(removeButton);
    buttonsLayout->addStretch();
    buttonsLayout->setContentsMargins(0, 0, 0, 0);

    setEquallySpacedButton = new QPushButton(tr("Set equally spaced"));
    setEquallySpacedButton->setProperty("mdButton", true);
    setEquallySpacedButton->setToolTip(tr("<b>Set equally spaced:</b> Clicking this button will cause the EddyPro to divide the whole 360&deg; circle in n equally-wide sectors, when n is the number of sectors currently entered. Note that the operation will not modify the north offset."));

    offsetLabel = new ClickLabel(tr("North offset first sector:"));
    offsetLabel->setToolTip(tr("<b>North offset first sector:</b> This parameter is meant to allow you design a sector that spans through the north. Entering an offset of a degrees will cause all sectors to rotate a degrees clockwise. Note that north is intended here as local, magnetic north (the one you assess with the compass at the site)."));
    offsetSpin = new QDoubleSpinBox;
    offsetSpin->setRange(-180.0, 180.0);
    offsetSpin->setDecimals(1);
    offsetSpin->setSingleStep(5.0);
    offsetSpin->setValue(0.0);
    offsetSpin->setSuffix(tr("  [%1]", "Degrees").arg(Defs::DEGREE));
    offsetSpin->setAccelerated(true);
    offsetSpin->setToolTip(offsetLabel->toolTip());

    auto offsetLayout = new QHBoxLayout;
    offsetLayout->addWidget(offsetLabel);
    offsetLayout->addSpacing(3);
    offsetLayout->addWidget(offsetSpin);

    auto sectorConfigLayout = new QGridLayout;
    sectorConfigLayout->addWidget(angleTableView_, 0, 0, Qt::AlignCenter);
    sectorConfigLayout->addLayout(buttonsLayout, 0, 1, Qt::AlignCenter);
    sectorConfigLayout->addWidget(anglesView_, 0, 2);
    sectorConfigLayout->addWidget(setEquallySpacedButton, 1, 0, Qt::AlignCenter);
    sectorConfigLayout->addLayout(offsetLayout, 1, 2);
    sectorConfigLayout->setVerticalSpacing(5);
    sectorConfigLayout->setContentsMargins(11, 0, 0, 0);

    sectorConfigFrame = new QWidget;
    sectorConfigFrame->setLayout(sectorConfigLayout);

    auto okButton = WidgetUtils::createCommonButton(this, tr("Ok"));

    propScrollArea = new QScrollArea;
    propScrollArea->setWidget(propertiesFrame);
    propScrollArea->setWidgetResizable(true);
    propScrollArea->setMinimumWidth(propertiesFrame->sizeHint().width());
    propScrollArea->setMaximumHeight(propertiesFrame->sizeHint().height());

    auto mainLayout = new QGridLayout(this);
    mainLayout->addWidget(groupTitle, 0, 0);
    mainLayout->addWidget(hrLabel_1, 1, 0);
    mainLayout->addWidget(propScrollArea, 3, 0);
    mainLayout->addWidget(hrLabel_2, 4, 0);
    mainLayout->addWidget(sectorConfigTitle, 5, 0);
    mainLayout->addWidget(sectorConfigFrame, 6, 0, Qt::AlignCenter);
    mainLayout->addWidget(okButton, 7, 0, 1, 1, Qt::AlignCenter);
    mainLayout->setVerticalSpacing(3);
    mainLayout->setContentsMargins(30, 30, 30, 30);
    setLayout(mainLayout);

    connect(radioGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(updatePfMode(int)));

    connect(radioGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(radioClicked(int)));

    connect(fileBrowse, &FileBrowseWidget::pathChanged,
            this, &PlanarFitSettingsDialog::updateFile);
    connect(fileBrowse, &FileBrowseWidget::pathSelected,
        this, &PlanarFitSettingsDialog::testSelectedFile);

    connect(subsetCheckBox, &QCheckBox::toggled,
            this, &PlanarFitSettingsDialog::updateSubsetSelection);

    connect(startDateLabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onStartDateLabelClicked);
    connect(startDateEdit, &QDateEdit::dateChanged,
            this, &PlanarFitSettingsDialog::updateStartDate);
    connect(startTimeEdit, &QTimeEdit::timeChanged,
            this, &PlanarFitSettingsDialog::updateStartTime);

    connect(endDateLabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onEndDateLabelClicked);
    connect(endDateEdit, &QDateEdit::dateChanged,
            this, &PlanarFitSettingsDialog::updateEndDate);
    connect(endTimeEdit, &QTimeEdit::timeChanged,
            this, &PlanarFitSettingsDialog::updateEndTime);

    connect(itemPerSectorLabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onItemPerSectorLabelClicked);
    connect(itemPerSectorSpin, SIGNAL(valueChanged(int)),
            this, SLOT(updateItemPerSector(int)));

    connect(maxAvgWLabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onMaxAvgWLabelClicked);
    connect(maxAvgWSpin, SIGNAL(valueChanged(double)),
            this, SLOT(updateMaxAvgW(double)));

    connect(minAvgULabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onMinAvgULabelClicked);
    connect(minAvgUSpin, SIGNAL(valueChanged(double)),
            this, SLOT(updateMinAvgU(double)));

    connect(fixPolicyLabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onFixPolicyLabelClicked);
    connect(fixPolicyCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(updateFixPolicy(int)));

    connect(setEquallySpacedButton, &QPushButton::clicked,
            this, &PlanarFitSettingsDialog::setEquallySpaced);

    connect(offsetLabel, &ClickLabel::clicked,
            this, &PlanarFitSettingsDialog::onOffsetLabelClicked);
    connect(offsetSpin, SIGNAL(valueChanged(double)),
            this, SLOT(setNorthOffset(double)));

    connect(angleTableModel_, SIGNAL(offsetChanged(double)),
            offsetSpin, SLOT(setValue(double)));
    connect(angleTableModel_, &AngleTableModel::modified,
            this, &PlanarFitSettingsDialog::modelModified);
    connect(angleTableModel_, &AngleTableModel::modelReset,
            ecProject_, &EcProject::updateInfo);

    connect(anglesView_, &AnglesView::fillPieRequest,
            this, &PlanarFitSettingsDialog::fillPie);

    connect(okButton, &QPushButton::clicked,
            this, &PlanarFitSettingsDialog::close);

    connect(ecProject_, &EcProject::ecProjectNew,
            this, &PlanarFitSettingsDialog::reset);

    connect(ecProject_, &EcProject::ecProjectModified,
            this, &PlanarFitSettingsDialog::updateModel);

    connect(ecProject_, &EcProject::ecProjectChanged,
            this, &PlanarFitSettingsDialog::refresh);

    // init
    forceEndDatePolicy();
    forceEndTimePolicy();
}

PlanarFitSettingsDialog::~PlanarFitSettingsDialog()
{
    qDebug() << Q_FUNC_INFO;
}

void PlanarFitSettingsDialog::close()
{
    DEBUG_FUNC_NAME
    if (isVisible())
        hide();
    emit saveRequest();
}

void PlanarFitSettingsDialog::reset()
{
    DEBUG_FUNC_NAME

    updatePfMode(1);

    existingRadio->setChecked(false);
    nonExistingRadio->setChecked(true);
    fileBrowse->clear();
    subsetCheckBox->setChecked(false);

    startDateEdit->setDate(QDate::fromString(ecProject_->generalStartDate(), Qt::ISODate));
    startTimeEdit->setTime(QTime::fromString(ecProject_->generalStartTime(), QStringLiteral("hh:mm")));
    endDateEdit->setDate(QDate::fromString(ecProject_->generalEndDate(), Qt::ISODate));
    endTimeEdit->setTime(QTime::fromString(ecProject_->generalEndTime(), QStringLiteral("hh:mm")));
    forceEndDatePolicy();
    forceEndTimePolicy();
    updateSubsetSelection(false);

    itemPerSectorSpin->setValue(0);
    maxAvgWSpin->setValue(0.099);
    minAvgUSpin->setValue(-0.001);
    fixPolicyCombo->setCurrentIndex(0);
    sectorConfigFrame->setEnabled(true);
    offsetSpin->setValue(0.0);

    angleTableModel_->clear();
    updateModel();
    resizeRows();

    radioClicked(1);
}

void PlanarFitSettingsDialog::refresh()
{
    DEBUG_FUNC_NAME

    // save the modified flag to prevent side effects of setting widgets
    bool oldmod = ecProject_->modified();
    ecProject_->blockSignals(true);

    existingRadio->setChecked(!ecProject_->planarFitMode());
    nonExistingRadio->setChecked(ecProject_->planarFitMode());

    fileBrowse->setPath(ecProject_->planarFitFile());

    subsetCheckBox->setChecked(ecProject_->planarFitSubset());
    if (ecProject_->planarFitSubset())
    {
        startDateEdit->setDate(QDate::fromString(ecProject_->planarFitStartDate(), Qt::ISODate));
        startTimeEdit->setTime(QTime::fromString(ecProject_->planarFitStartTime(), QStringLiteral("hh:mm")));
        endDateEdit->setDate(QDate::fromString(ecProject_->planarFitEndDate(), Qt::ISODate));
        endTimeEdit->setTime(QTime::fromString(ecProject_->planarFitEndTime(), QStringLiteral("hh:mm")));
    }
    else
    {
        startDateEdit->setDate(QDate::fromString(ecProject_->generalStartDate(), Qt::ISODate));
        startTimeEdit->setTime(QTime::fromString(ecProject_->generalStartTime(), QStringLiteral("hh:mm")));
        endDateEdit->setDate(QDate::fromString(ecProject_->generalEndDate(), Qt::ISODate));
        endTimeEdit->setTime(QTime::fromString(ecProject_->generalEndTime(), QStringLiteral("hh:mm")));
    }

    offsetSpin->setValue(ecProject_->planarFitNorthOffset());
    itemPerSectorSpin->setValue(ecProject_->planarFitItemPerSector());
    maxAvgWSpin->setValue(ecProject_->planarFitWmax());
    minAvgUSpin->setValue(ecProject_->planarFitUmin());
    fixPolicyCombo->setCurrentIndex(ecProject_->planarFitFixPolicy());

    updateModel();
    resizeRows();

    radioClicked(ecProject_->planarFitMode());

    // restore modified flag
    ecProject_->setModified(oldmod);
    ecProject_->blockSignals(false);
}

void PlanarFitSettingsDialog::partialRefresh()
{
    DEBUG_FUNC_NAME

    // save the modified flag to prevent side effects of setting widgets
    bool oldmod = ecProject_->modified();
    ecProject_->blockSignals(true);

    subsetCheckBox->setChecked(ecProject_->planarFitSubset());
    if (ecProject_->planarFitSubset())
    {
        startDateEdit->setDate(QDate::fromString(ecProject_->planarFitStartDate(), Qt::ISODate));
        startTimeEdit->setTime(QTime::fromString(ecProject_->planarFitStartTime(), QStringLiteral("hh:mm")));
        endDateEdit->setDate(QDate::fromString(ecProject_->planarFitEndDate(), Qt::ISODate));
        endTimeEdit->setTime(QTime::fromString(ecProject_->planarFitEndTime(), QStringLiteral("hh:mm")));
    }
    else
    {
        startDateEdit->setDate(QDate::fromString(ecProject_->generalStartDate(), Qt::ISODate));
        startTimeEdit->setTime(QTime::fromString(ecProject_->generalStartTime(), QStringLiteral("hh:mm")));
        endDateEdit->setDate(QDate::fromString(ecProject_->generalEndDate(), Qt::ISODate));
        endTimeEdit->setTime(QTime::fromString(ecProject_->generalEndTime(), QStringLiteral("hh:mm")));
    }

    // restore modified flag
    ecProject_->setModified(oldmod);
    ecProject_->blockSignals(false);
}

void PlanarFitSettingsDialog::setDateRange(QPair<QDateTime, QDateTime> dates)
{
    DEBUG_FUNC_NAME
    qDebug() << dates.first.date();
    if (!ecProject_->planarFitSubset())
    {
        startDateEdit->setDate(dates.first.date());
        endDateEdit->setDate(dates.second.date());
    }
}

void PlanarFitSettingsDialog::updateFile(const QString& fp)
{
    ecProject_->setPlanarFitFile(QDir::cleanPath(fp));
}

void PlanarFitSettingsDialog::testSelectedFile(const QString& fp)
{
    QFileInfo paramFilePath(fp);
    auto canonicalParamFile = paramFilePath.canonicalFilePath();

    AncillaryFileTest test_dialog(AncillaryFileTest::FileType::PlanarFit, this);
    test_dialog.refresh(canonicalParamFile);

    auto test_result = test_dialog.makeTest();
    qDebug() << "test_result" << test_result;

    auto dialog_result = true;

    // blocking behavior if test fails
    if (!test_result)
    {
        dialog_result = test_dialog.exec();
    }

    if (dialog_result)
    {
        fileBrowse->setPath(fp);

        auto lastPath = paramFilePath.canonicalPath();
        configState_->window.last_data_path = lastPath;
        GlobalSettings::updateLastDatapath(lastPath);
    }
    else
    {
        fileBrowse->clear();
    }
}

void PlanarFitSettingsDialog::onOffsetLabelClicked()
{
    offsetSpin->setFocus();
    offsetSpin->selectAll();
}

void PlanarFitSettingsDialog::onItemPerSectorLabelClicked()
{
    itemPerSectorSpin->setFocus();
    itemPerSectorSpin->selectAll();
}

void PlanarFitSettingsDialog::onMaxAvgWLabelClicked()
{
    maxAvgWSpin->setFocus();
    maxAvgWSpin->selectAll();
}

void PlanarFitSettingsDialog::onMinAvgULabelClicked()
{
    minAvgUSpin->setFocus();
    minAvgUSpin->selectAll();
}

void PlanarFitSettingsDialog::updatePfMode(int radioButton)
{
    ecProject_->setPlanarFitMode(radioButton);
}

void PlanarFitSettingsDialog::radioClicked(int radioButton)
{

    if (radioButton == 0)
    {
        fileBrowse->setEnabled(true);
        subsetCheckBox->setEnabled(false);
        startDateLabel->setEnabled(false);
        startDateEdit->setEnabled(false);
        lockedIcon->setEnabled(false);
        endDateLabel->setEnabled(false);
        endDateEdit->setEnabled(false);
        itemPerSectorLabel->setEnabled(false);
        itemPerSectorSpin->setEnabled(false);
        maxAvgWLabel->setEnabled(false);
        maxAvgWSpin->setEnabled(false);
        minAvgULabel->setEnabled(false);
        minAvgUSpin->setEnabled(false);
        sectorConfigFrame->setEnabled(false);
    }
    else
    {
        fileBrowse->setEnabled(false);
        subsetCheckBox->setEnabled(true);
        startDateLabel->setEnabled(subsetCheckBox->isChecked());
        startDateEdit->setEnabled(subsetCheckBox->isChecked());
        lockedIcon->setEnabled(subsetCheckBox->isChecked());
        endDateLabel->setEnabled(subsetCheckBox->isChecked());
        endDateEdit->setEnabled(subsetCheckBox->isChecked());
        itemPerSectorLabel->setEnabled(true);
        itemPerSectorSpin->setEnabled(true);
        maxAvgWLabel->setEnabled(true);
        maxAvgWSpin->setEnabled(true);
        minAvgULabel->setEnabled(true);
        minAvgUSpin->setEnabled(true);
        sectorConfigFrame->setEnabled(true);
    }
}

void PlanarFitSettingsDialog::updateItemPerSector(int n)
{
    ecProject_->setPlanarFitItemPerSector(n);
}

void PlanarFitSettingsDialog::updateMaxAvgW(double d)
{
    ecProject_->setPlanarFitWmax(d);
}

void PlanarFitSettingsDialog::updateMinAvgU(double d)
{
    ecProject_->setPlanarFitUmin(d);
}

void PlanarFitSettingsDialog::onStartDateLabelClicked()
{
    DEBUG_FUNC_NAME
    startDateEdit->setFocus();
    WidgetUtils::showCalendarOf(startDateEdit);
}

void PlanarFitSettingsDialog::onEndDateLabelClicked()
{
    endDateEdit->setFocus();
    WidgetUtils::showCalendarOf(endDateEdit);
}

void PlanarFitSettingsDialog::updateStartDate(const QDate &d)
{
    ecProject_->setPlanarFitStartDate(d.toString(Qt::ISODate));
    forceEndDatePolicy();
}

void PlanarFitSettingsDialog::updateStartTime(const QTime& t)
{
    ecProject_->setPlanarFitStartTime(t.toString(QStringLiteral("hh:mm")));
    forceEndTimePolicy();
}

void PlanarFitSettingsDialog::updateEndDate(const QDate &d)
{
    ecProject_->setPlanarFitEndDate(d.toString(Qt::ISODate));
}

void PlanarFitSettingsDialog::updateEndTime(const QTime& t)
{
    ecProject_->setPlanarFitEndTime(t.toString(QStringLiteral("hh:mm")));
}

// enforce (start date&time) <= (end date&time)
void PlanarFitSettingsDialog::forceEndDatePolicy()
{
    DEBUG_FUNC_NAME

    endDateEdit->setMinimumDate(startDateEdit->date());
}

// enforce (start date&time) <= (end date&time)
void PlanarFitSettingsDialog::forceEndTimePolicy()
{
    DEBUG_FUNC_NAME

    qDebug() << "start - end, dates:" << startDateEdit->date() << endDateEdit->date();

    if (startDateEdit->date() == endDateEdit->date())
    {
        endTimeEdit->setMinimumTime(startTimeEdit->time());
    }
    else
    {
        endTimeEdit->clearMinimumTime();
    }
}

void PlanarFitSettingsDialog::onFixPolicyLabelClicked()
{
    fixPolicyCombo->setFocus();
    fixPolicyCombo->showPopup();
}

void PlanarFitSettingsDialog::updateFixPolicy(int n)
{
    ecProject_->setPlanarFitPolicy(n);
}

void PlanarFitSettingsDialog::setupModel()
{
    angleTableModel_ = new AngleTableModel(this, ecProject_->planarFitAngles());
}

void PlanarFitSettingsDialog::setupViews()
{
    addButton = new QToolButton;
    addButton->setObjectName(QStringLiteral("plusButton"));
    addButton->setToolTip(tr("<b>+</b> Add an angle."));

    removeButton = new QToolButton;
    removeButton->setObjectName(QStringLiteral("minusButton"));
    removeButton->setToolTip(tr("<b>-</b> Remove an angle."));

    connect(addButton, &QToolButton::clicked,
            this, &PlanarFitSettingsDialog::addAngle);
    connect(removeButton, &QToolButton::clicked,
            this, &PlanarFitSettingsDialog::removeAngle);

    angleTableView_ = new AngleTableView(this);
    angleTableView_->setModel(angleTableModel_);
    angleTableView_->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
    angleTableView_->setToolTip(tr("<b>Planar fit:</b> Visualization of the described wind sectors. Add or remove wind sector using the <b>+</b> and <b>-</b> buttons on the left."));

    anglesView_ = new AnglesView(this);
    anglesView_->setModel(angleTableModel_);
    anglesView_->setToolTip(tr("<b>Planar fit:</b> Visualization of the described wind sectors. Add or remove wind sector using the <b>+</b> and <b>-</b> buttons on the left. Use the north-offset to design a sector that spans through the north. At any time, double click on the empty space of the pie to fill the circle with one more sector, wide right enough to close the 360&deg; angle."));
    qDebug() << "model_ rows" << angleTableModel_->rowCount();

    anglesView_->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    anglesView_->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    anglesView_->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);

    angleSelectionModel_ = new QItemSelectionModel(angleTableModel_);

    angleTableView_->setSelectionModel(angleSelectionModel_);
    angleTableView_->setSelectionMode(QAbstractItemView::SingleSelection);

    anglesView_->setSelectionModel(angleSelectionModel_);
    anglesView_->setSelectionMode(QAbstractItemView::SingleSelection);

    QHeaderView *headerView = angleTableView_->horizontalHeader();
    headerView->setModel(angleTableModel_);
    headerView->setStretchLastSection(true);
    headerView->setHighlightSections(false);
    headerView->setProperty("pieTableH", true);

    QHeaderView *vHeaderView = angleTableView_->verticalHeader();
    vHeaderView->setProperty("pieTableV", true);

    connect(anglesView_, SIGNAL(clicked(QModelIndex)),
            angleTableView_, SLOT(edit(QModelIndex)));
}

void PlanarFitSettingsDialog::insertAngleAt(int row)
{
    if (!angleTableModel_->insertRow(row))
    {
        qDebug() << "insertion failed";
        return;
    }
    QModelIndex currIndex = angleTableModel_->index(row - 1, 0);
    anglesView_->setCurrentIndex(currIndex);
    angleTableModel_->flush();
}

void PlanarFitSettingsDialog::removeAngleAt(int row)
{
    if (!angleTableModel_->removeRow(row))
    {
        qDebug() << "deletion failed";
        return;
    }
    if (row > 0)
    {
        QModelIndex currIndex = angleTableModel_->index(row - 1, 0);
        anglesView_->setCurrentIndex(currIndex);
    }
    angleTableModel_->flush();
}

void PlanarFitSettingsDialog::addAngle()
{
    DEBUG_FUNC_NAME

    int selectedRow = angleSelectionModel_->currentIndex().row();
    int lastRow = angleTableModel_->rowCount();

    qDebug() << "selectedRow" << selectedRow;
    qDebug() << "lastRow" << lastRow;

    if (selectedRow < 0)
    {
        insertAngleAt(lastRow);
    }
    else
    {
        insertAngleAt(selectedRow + 1);
    }
    resizeRows();
}

void PlanarFitSettingsDialog::removeAngle()
{
    int selectedRow = angleSelectionModel_->currentIndex().row();
    int lastRow = angleTableModel_->rowCount();

    qDebug() << "selectedRow" << selectedRow;
    qDebug() << "lastRow" << lastRow;

    if (lastRow > 0)
    {
        if (selectedRow < 0)
        {
            removeAngleAt(lastRow - 1);
        }
        else
        {
            removeAngleAt(selectedRow);
        }
    }
    resizeRows();
}

void PlanarFitSettingsDialog::resizeRows()
{
    for (int i = 0; i < angleTableModel_->rowCount(); i++)
    {
        angleTableView_->resizeRowToContents(i);
    }
}

void PlanarFitSettingsDialog::setEquallySpaced()
{
    DEBUG_FUNC_NAME

    int angleCount = angleTableModel_->rowCount();
    double angle = 360.0 / angleCount;
    qDebug() << "angleCount" << angleCount;
    qDebug() << "angle" << angle;

    angleTableModel_->setSkipPruning(true);
    for (int n = 0; n < angleCount; ++n)
    {
        angleTableModel_->setData(angleTableModel_->index(n, 0), angle);
    }
    angleTableModel_->setSkipPruning(false);
    angleTableModel_->flush();
}

void PlanarFitSettingsDialog::setNorthOffset(double angle)
{
    ecProject_->setPlanarFitNorthOffset(angle);

    angleTableModel_->setOffset(angle);
    angleTableModel_->flush();
}

void PlanarFitSettingsDialog::fillPie()
{
    double fullAngle = 360.0;
    int angleCount = angleTableModel_->rowCount();

    if (angleTableModel_->angleSum() < fullAngle)
    {
        addAngle();
        angleTableModel_->setData(angleTableModel_->index(angleCount, 0), fullAngle);
    }
    angleTableModel_->flush();
}

void PlanarFitSettingsDialog::modelModified()
{
    ecProject_->setModified(true);
    anglesView_->updateValidItems();
}

void PlanarFitSettingsDialog::updateModel()
{
    DEBUG_FUNC_NAME

    angleTableModel_->flush();
    anglesView_->updateValidItems();
}

void PlanarFitSettingsDialog::updateSubsetSelection(bool b)
{
    ecProject_->setPlanarFitSubset(b);

    foreach (QWidget *w,
             QWidgetList() << startDateLabel
                           << startDateEdit
                           << startTimeEdit
                           << lockedIcon
                           << endDateLabel
                           << endDateEdit
                           << endTimeEdit)
    {
        w->setEnabled(b);
    }
}

void PlanarFitSettingsDialog::setSmartfluxUI()
{
    bool on = configState_->project.smartfluxMode;

    nonExistingRadio->setDisabled(on);

    // block project modified() signal
    auto oldmod = false;
    if (!on)
    {
        // save the modified flag to prevent side effects of setting widgets
        oldmod = ecProject_->modified();
        ecProject_->blockSignals(true);
    }

    if (on)
    {
        radioGroup->button(0)->click();
    }

    // restore project modified() signal
    if (!on)
    {
        // restore modified flag
        ecProject_->setModified(oldmod);
        ecProject_->blockSignals(false);
    }
}
